#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
============================================================================
Lorentzian Classification Trading Bot - Ù†Ø³Ø®Ø© ÙƒØ§Ù…Ù„Ø© ÙˆÙ…Ø³ØªÙ‚Ù„Ø©
============================================================================
ØªØ­ÙˆÙŠÙ„ ÙƒØ§Ù…Ù„ Ù„Ù…Ø¤Ø´Ø± Lorentzian Classification Ù…Ù† Pine Script Ø¥Ù„Ù‰ Python
Ù„Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø¢Ù„ÙŠ Ø¹Ù„Ù‰ Ù…Ù†ØµØ© cTrader Ù…Ø¹ FxPro

Ø§Ù„Ù…Ø¤Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ: @jdehorty
Ø§Ù„ØªØ±Ø®ÙŠØµ: Mozilla Public License 2.0
============================================================================
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import time
import logging
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø¬Ù„Ø§Øª
# ============================================================================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('trading_bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© (ÙƒÙ„ Ø´ÙŠØ¡ ÙÙŠ Ù…ÙƒØ§Ù† ÙˆØ§Ø­Ø¯)
# ============================================================================

class Config:
    """Ø¬Ù…ÙŠØ¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙƒÙ„Ø§Ø³ ÙˆØ§Ø­Ø¯"""
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª cTrader API ==============
    # âš ï¸ Ø¶Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª API Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ù‡Ù†Ø§
    CTRADER_CLIENT_ID = "your_client_id_here"
    CTRADER_CLIENT_SECRET = "your_client_secret_here"
    CTRADER_ACCOUNT_ID = "your_account_id_here"
    CTRADER_BASE_URL = "https://demo.ctraderapi.com"
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ==============
    SYMBOL = "EURUSD"
    TIMEFRAME = "M1"  # Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©
    LEVERAGE = 10000  # Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© 1:10000
    INITIAL_BALANCE = 100.0  # Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±
    USE_CUMULATIVE_BALANCE = True  # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ ==============
    NEIGHBORS_COUNT = 8  # Ø¹Ø¯Ø¯ Ø§Ù„Ø¬ÙŠØ±Ø§Ù†
    MAX_BARS_BACK = 2000  # Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
    FEATURE_COUNT = 5  # Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Øª
    USE_DYNAMIC_EXITS = False  # Ù…Ø®Ø§Ø±Ø¬ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙÙ„Ø§ØªØ± ==============
    USE_VOLATILITY_FILTER = True
    USE_REGIME_FILTER = True
    USE_ADX_FILTER = False
    REGIME_THRESHOLD = -0.1
    ADX_THRESHOLD = 20
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª EMA Ùˆ SMA ==============
    USE_EMA_FILTER = False
    EMA_PERIOD = 200
    USE_SMA_FILTER = False
    SMA_PERIOD = 200
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Kernel Regression ==============
    USE_KERNEL_FILTER = True
    USE_KERNEL_SMOOTHING = False
    KERNEL_H = 8  # Lookback Window
    KERNEL_R = 8.0  # Relative Weighting
    KERNEL_X = 25  # Regression Level
    KERNEL_LAG = 2
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ÙŠØ²Ø§Øª ==============
    # Feature 1
    F1_TYPE = "RSI"
    F1_PARAM_A = 14
    F1_PARAM_B = 1
    
    # Feature 2
    F2_TYPE = "WT"
    F2_PARAM_A = 10
    F2_PARAM_B = 11
    
    # Feature 3
    F3_TYPE = "CCI"
    F3_PARAM_A = 20
    F3_PARAM_B = 1
    
    # Feature 4
    F4_TYPE = "ADX"
    F4_PARAM_A = 20
    F4_PARAM_B = 2
    
    # Feature 5
    F5_TYPE = "RSI"
    F5_PARAM_A = 9
    F5_PARAM_B = 1
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± ==============
    MAX_POSITION_SIZE = 100.0  # Ø­Ø¯ Ø£Ù‚ØµÙ‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ø¨Ø§Ù„Ù„ÙˆØª
    STOP_LOSS_PIPS = 0  # ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© (0 = Ù…Ø¹Ø·Ù„)
    TAKE_PROFIT_PIPS = 0  # Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ (0 = Ù…Ø¹Ø·Ù„)
    MAX_DAILY_LOSS = 0  # Ø­Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (0 = Ù…Ø¹Ø·Ù„)
    
    # ============== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„ ==============
    UPDATE_INTERVAL_SECONDS = 60  # Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 60 Ø«Ø§Ù†ÙŠØ© (Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©)
    USE_DEMO_MODE = True  # ÙˆØ¶Ø¹ ØªØ¬Ø±ÙŠØ¨ÙŠ (Ù…Ø­Ø§ÙƒØ§Ø©)


# ============================================================================
# Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© (ÙƒÙ„ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ù…Ù† Pine Script)
# ============================================================================

class TechnicalIndicators:
    """Ø­Ø³Ø§Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
    
    @staticmethod
    def rsi(data: pd.Series, period: int = 14) -> pd.Series:
        """Ù…Ø¤Ø´Ø± Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù†Ø³Ø¨ÙŠØ© RSI"""
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        # ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
        rs = gain / loss.replace(0, np.nan)
        rsi = 100 - (100 / (1 + rs))
        return rsi.fillna(50)  # Ø§Ù…Ù„Ø£ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù†Ø§Ù‚ØµØ© Ø¨Ù€ 50
    
    @staticmethod
    def normalize_rsi(data: pd.Series, period: int, param_b: int = 1) -> pd.Series:
        """RSI Ù…Ø·Ø¨Ù‘Ø¹ Ù…Ù† -1 Ø¥Ù„Ù‰ 1"""
        rsi_val = TechnicalIndicators.rsi(data, period)
        return (rsi_val - 50) / 50
    
    @staticmethod
    def wt(hlc3: pd.Series, period_a: int, period_b: int) -> pd.Series:
        """WaveTrend Ù…Ø¤Ø´Ø± Ø§Ù„Ù…ÙˆØ¬Ø©"""
        esa = hlc3.ewm(span=period_a, adjust=False).mean()
        d = (hlc3 - esa).abs().ewm(span=period_a, adjust=False).mean()
        d = d.replace(0, 0.001)  # ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
        ci = (hlc3 - esa) / (0.015 * d)
        wt1 = ci.ewm(span=period_b, adjust=False).mean()
        return wt1 / 100  # ØªØ·Ø¨ÙŠØ¹
    
    @staticmethod
    def cci(data: pd.Series, period: int) -> pd.Series:
        """Commodity Channel Index"""
        tp = data
        sma = tp.rolling(window=period).mean()
        mad = (tp - sma).abs().rolling(window=period).mean()
        mad = mad.replace(0, 0.001)  # ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
        cci = (tp - sma) / (0.015 * mad)
        return cci / 100  # ØªØ·Ø¨ÙŠØ¹
    
    @staticmethod
    def adx(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
        """Average Directional Index"""
        tr1 = high - low
        tr2 = (high - close.shift(1)).abs()
        tr3 = (low - close.shift(1)).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        
        plus_dm = high.diff()
        minus_dm = -low.diff()
        plus_dm[plus_dm < 0] = 0
        minus_dm[minus_dm < 0] = 0
        
        atr = tr.rolling(window=period).mean()
        atr = atr.replace(0, 0.001)  # ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
        
        plus_di = 100 * (plus_dm.rolling(window=period).mean() / atr)
        minus_di = 100 * (minus_dm.rolling(window=period).mean() / atr)
        
        dx_denominator = (plus_di + minus_di).replace(0, 0.001)
        dx = 100 * ((plus_di - minus_di).abs() / dx_denominator)
        adx = dx.rolling(window=period).mean()
        return adx / 100  # ØªØ·Ø¨ÙŠØ¹
    
    @staticmethod
    def ema(data: pd.Series, period: int) -> pd.Series:
        """Exponential Moving Average"""
        return data.ewm(span=period, adjust=False).mean()
    
    @staticmethod
    def sma(data: pd.Series, period: int) -> pd.Series:
        """Simple Moving Average"""
        return data.rolling(window=period).mean()
    
    @staticmethod
    def atr(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
        """Average True Range"""
        tr1 = high - low
        tr2 = (high - close.shift(1)).abs()
        tr3 = (low - close.shift(1)).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        return tr.rolling(window=period).mean()


# ============================================================================
# Ù…Ø­Ø±Ùƒ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ (Lorentzian Classifier)
# ============================================================================

class LorentzianClassifier:
    """Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø³Ø§ÙØ© Ù„ÙˆØ±Ù†ØªØ²"""
    
    def __init__(self):
        self.config = Config()
        
        # Ù…ØµÙÙˆÙØ§Øª Ø§Ù„Ù…ÙŠØ²Ø§Øª
        self.feature_arrays = {
            'f1': [],
            'f2': [],
            'f3': [],
            'f4': [],
            'f5': []
        }
        
        # Ù…ØµÙÙˆÙØ§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¨
        self.y_train_array = []
        self.predictions = []
        self.distances = []
        
        # Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
        self.last_signal = 0
        self.bars_held = 0
        
        logger.info("ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù†Ù…ÙˆØ°Ø¬ Lorentzian Classifier")
    
    def get_feature_series(self, df: pd.DataFrame) -> Dict[str, pd.Series]:
        """Ø­Ø³Ø§Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø®Ù…Ø³"""
        close = df['close']
        high = df['high']
        low = df['low']
        hlc3 = (high + low + close) / 3
        
        features = {}
        
        # Feature 1
        features['f1'] = self._series_from(
            self.config.F1_TYPE, close, high, low, hlc3,
            self.config.F1_PARAM_A, self.config.F1_PARAM_B
        )
        
        # Feature 2
        features['f2'] = self._series_from(
            self.config.F2_TYPE, close, high, low, hlc3,
            self.config.F2_PARAM_A, self.config.F2_PARAM_B
        )
        
        # Feature 3
        features['f3'] = self._series_from(
            self.config.F3_TYPE, close, high, low, hlc3,
            self.config.F3_PARAM_A, self.config.F3_PARAM_B
        )
        
        # Feature 4
        features['f4'] = self._series_from(
            self.config.F4_TYPE, close, high, low, hlc3,
            self.config.F4_PARAM_A, self.config.F4_PARAM_B
        )
        
        # Feature 5
        features['f5'] = self._series_from(
            self.config.F5_TYPE, close, high, low, hlc3,
            self.config.F5_PARAM_A, self.config.F5_PARAM_B
        )
        
        return features
    
    def _series_from(self, feature_string: str, close: pd.Series, high: pd.Series,
                     low: pd.Series, hlc3: pd.Series, param_a: int, param_b: int) -> pd.Series:
        """Ø­Ø³Ø§Ø¨ Ù…ÙŠØ²Ø© ÙˆØ§Ø­Ø¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹Ù‡Ø§"""
        if feature_string == "RSI":
            return TechnicalIndicators.normalize_rsi(close, param_a, param_b)
        elif feature_string == "WT":
            return TechnicalIndicators.wt(hlc3, param_a, param_b)
        elif feature_string == "CCI":
            return TechnicalIndicators.cci(close, param_a)
        elif feature_string == "ADX":
            return TechnicalIndicators.adx(high, low, close, param_a)
        else:
            return pd.Series([0] * len(close), index=close.index)
    
    def get_lorentzian_distance(self, i: int, current_features: Dict[str, float]) -> float:
        """Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§ÙØ© Ù„ÙˆØ±Ù†ØªØ² Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©"""
        distance = 0.0
        
        for feature_name in ['f1', 'f2', 'f3', 'f4', 'f5'][:self.config.FEATURE_COUNT]:
            if i < len(self.feature_arrays[feature_name]):
                historical_value = self.feature_arrays[feature_name][i]
                current_value = current_features[feature_name]
                
                # Ù…Ø³Ø§ÙØ© Ù„ÙˆØ±Ù†ØªØ²: log(1 + |x - y|)
                distance += np.log(1 + np.abs(current_value - historical_value))
        
        return distance
    
    def apply_filters(self, df: pd.DataFrame, idx: int) -> bool:
        """ØªØ·Ø¨ÙŠÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙ„Ø§ØªØ±"""
        
        # Volatility Filter (Ù…Ø¨Ø³Ø·)
        volatility_filter = True
        if self.config.USE_VOLATILITY_FILTER:
            # ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ†Ù‡ Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ù„Ø¨ Ø§Ù„ÙØ¹Ù„ÙŠ
            volatility_filter = True
        
        # Regime Filter
        regime_filter = True
        if self.config.USE_REGIME_FILTER:
            # ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ†Ù‡ Ø¨ÙƒØ´Ù Ø§Ù„Ø§ØªØ¬Ø§Ù‡
            regime_filter = True
        
        # ADX Filter
        adx_filter = True
        if self.config.USE_ADX_FILTER:
            try:
                adx_value = TechnicalIndicators.adx(
                    df['high'], df['low'], df['close'], 14
                ).iloc[idx]
                adx_filter = adx_value > (self.config.ADX_THRESHOLD / 100)
            except:
                adx_filter = True
        
        return volatility_filter and regime_filter and adx_filter
    
    def rational_quadratic_kernel(self, source: pd.Series, h: int, r: float, x: int) -> pd.Series:
        """Rational Quadratic Kernel Regression"""
        result = source.copy()
        size = len(source)
        
        for i in range(x, size):
            sum_weights = 0.0
            sum_values = 0.0
            
            for j in range(max(0, i - h), i):
                # Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆØ²Ù†
                w = (1 + ((i - j) ** 2) / (2 * r * h ** 2)) ** (-r)
                sum_weights += w
                sum_values += w * source.iloc[j]
            
            if sum_weights > 0:
                result.iloc[i] = sum_values / sum_weights
        
        return result
    
    def predict(self, df: pd.DataFrame, current_idx: int) -> Tuple[int, Dict]:
        """Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© KNN Ù…Ø¹ Ù…Ø³Ø§ÙØ© Ù„ÙˆØ±Ù†ØªØ²"""
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        feature_series = self.get_feature_series(df)
        current_features = {}
        
        for i in range(self.config.FEATURE_COUNT):
            feature_name = f'f{i+1}'
            try:
                current_features[feature_name] = feature_series[feature_name].iloc[current_idx]
                # ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ØµØ§Ù„Ø­Ø©
                if np.isnan(current_features[feature_name]) or np.isinf(current_features[feature_name]):
                    current_features[feature_name] = 0.0
            except:
                current_features[feature_name] = 0.0
        
        # ØªØ­Ø¯ÙŠØ« Ù…ØµÙÙˆÙØ§Øª Ø§Ù„Ù…ÙŠØ²Ø§Øª
        for i in range(self.config.FEATURE_COUNT):
            feature_name = f'f{i+1}'
            self.feature_arrays[feature_name].append(current_features[feature_name])
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ³Ù…ÙŠØ© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ÙŠØ© (Training Label)
        # y_train = src[4] < src[0] ? -1 : src[4] > src[0] ? 1 : 0
        if current_idx >= 4:
            try:
                src_current = df['close'].iloc[current_idx]
                src_future = df['close'].iloc[current_idx - 4]
                
                if src_future < src_current:
                    label = -1  # short
                elif src_future > src_current:
                    label = 1   # long
                else:
                    label = 0   # neutral
                
                self.y_train_array.append(label)
            except:
                pass
        
        # Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Approximate Nearest Neighbors
        self.predictions.clear()
        self.distances.clear()
        
        last_distance = -1.0
        size = min(self.config.MAX_BARS_BACK - 1, len(self.y_train_array) - 1)
        
        for i in range(0, size):
            if i % 4 == 0:  # ØªØ¨Ø§Ø¹Ø¯ Ø²Ù…Ù†ÙŠ ÙƒÙ„ 4 Ø£Ø´Ø±Ø·Ø©
                d = self.get_lorentzian_distance(i, current_features)
                
                if d >= last_distance:
                    last_distance = d
                    self.distances.append(d)
                    if i < len(self.y_train_array):
                        self.predictions.append(self.y_train_array[i])
                    
                    # Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
                    if len(self.predictions) > self.config.NEIGHBORS_COUNT:
                        quartile_idx = int(self.config.NEIGHBORS_COUNT * 3 / 4)
                        if quartile_idx < len(self.distances):
                            last_distance = self.distances[quartile_idx]
                        self.distances.pop(0)
                        self.predictions.pop(0)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
        prediction = sum(self.predictions) if self.predictions else 0
        
        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
        filter_all = self.apply_filters(df, current_idx)
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
        if prediction > 0 and filter_all:
            signal = 1  # long
        elif prediction < 0 and filter_all:
            signal = -1  # short
        else:
            signal = 0  # neutral
        
        # Ø­Ø³Ø§Ø¨ Kernel Regression
        kernel_info = {'is_bullish': True, 'is_bearish': True}
        
        if self.config.USE_KERNEL_FILTER:
            try:
                yhat1 = self.rational_quadratic_kernel(
                    df['close'],
                    self.config.KERNEL_H,
                    self.config.KERNEL_R,
                    self.config.KERNEL_X
                )
                
                if current_idx >= 1:
                    is_bullish_rate = yhat1.iloc[current_idx] > yhat1.iloc[current_idx - 1]
                    kernel_info['is_bullish'] = is_bullish_rate
                    kernel_info['is_bearish'] = not is_bullish_rate
            except:
                pass
        
        # ÙÙ„Ø§ØªØ± EMA Ùˆ SMA
        ema_filter = True
        sma_filter = True
        
        try:
            if self.config.USE_EMA_FILTER:
                ema_val = TechnicalIndicators.ema(df['close'], self.config.EMA_PERIOD)
                current_price = df['close'].iloc[current_idx]
                if signal == 1:
                    ema_filter = current_price > ema_val.iloc[current_idx]
                elif signal == -1:
                    ema_filter = current_price < ema_val.iloc[current_idx]
            
            if self.config.USE_SMA_FILTER:
                sma_val = TechnicalIndicators.sma(df['close'], self.config.SMA_PERIOD)
                current_price = df['close'].iloc[current_idx]
                if signal == 1:
                    sma_filter = current_price > sma_val.iloc[current_idx]
                elif signal == -1:
                    sma_filter = current_price < sma_val.iloc[current_idx]
        except:
            pass
        
        # ØªØ·Ø¨ÙŠÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙ„Ø§ØªØ±
        if not (ema_filter and sma_filter):
            signal = 0
        
        return signal, kernel_info


# ============================================================================
# ÙˆØ§Ø¬Ù‡Ø© cTrader API (Ù…Ø¹ ÙˆØ¶Ø¹ Ù…Ø­Ø§ÙƒØ§Ø©)
# ============================================================================

class CTraderAPI:
    """ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ cTrader API"""
    
    def __init__(self):
        self.config = Config()
        self.current_balance = self.config.INITIAL_BALANCE
        self.current_position = None
        self.trades_history = []
        self.demo_mode = self.config.USE_DEMO_MODE
        
        logger.info(f"ØªÙ… ØªÙ‡ÙŠØ¦Ø© CTrader API - Ø§Ù„ÙˆØ¶Ø¹: {'Ù…Ø­Ø§ÙƒØ§Ø©' if self.demo_mode else 'Ø­Ù‚ÙŠÙ‚ÙŠ'}")
    
    def get_current_balance(self) -> float:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        return self.current_balance
    
    def get_historical_data(self, bars: int = 2500) -> pd.DataFrame:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©"""
        
        if self.demo_mode:
            # ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ÙˆØ§Ù‚Ø¹ÙŠØ©
            logger.info(f"Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ {bars} Ø´Ù…Ø¹Ø© (ÙˆØ¶Ø¹ Ù…Ø­Ø§ÙƒØ§Ø©)...")
            
            dates = pd.date_range(end=datetime.now(), periods=bars, freq='1min')
            np.random.seed(int(time.time()) % 10000)
            
            # Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ø¹Ø± Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©
            base_price = 1.1000
            returns = np.random.normal(0, 0.00005, bars)  # ØªÙ‚Ù„Ø¨ ÙˆØ§Ù‚Ø¹ÙŠ
            prices = base_price * (1 + returns).cumprod()
            
            df = pd.DataFrame({
                'timestamp': dates,
                'open': prices * (1 + np.random.uniform(-0.00005, 0.00005, bars)),
                'high': prices * (1 + np.random.uniform(0, 0.0001, bars)),
                'low': prices * (1 + np.random.uniform(-0.0001, 0, bars)),
                'close': prices,
                'volume': np.random.randint(100, 1000, bars)
            })
            
            logger.info(f"ØªÙ… Ø¬Ù„Ø¨ {len(df)} Ø´Ù…Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­")
            return df
        
        else:
            # ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø§Ø³ØªØ®Ø¯Ù… API Ø§Ù„ÙØ¹Ù„ÙŠ
            # Ù‡Ù†Ø§ ÙŠØ¬Ø¨ Ø¥Ø¶Ø§ÙØ© ÙƒÙˆØ¯ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ Ø¨Ù€ cTrader
            logger.warning("Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ Ø¨Ø¹Ø¯ - Ø§Ø³ØªØ®Ø¯Ù… USE_DEMO_MODE = True")
            return None
    
    def calculate_position_size(self) -> float:
        """Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        # Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© = Ø§Ù„Ø±ØµÙŠØ¯ Ã— Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© / 100,000
        position_value = self.current_balance * self.config.LEVERAGE
        lot_size = position_value / 100000
        
        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
        lot_size = min(lot_size, self.config.MAX_POSITION_SIZE)
        
        return round(lot_size, 2)
    
    def open_position(self, signal_type: str, current_price: float) -> bool:
        """ÙØªØ­ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø©"""
        try:
            # Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…Ø¹Ø§ÙƒØ³Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
            if self.current_position:
                opposite_type = 'sell' if signal_type == 'buy' else 'buy'
                if self.current_position['type'] == opposite_type:
                    self.close_position(current_price)
            
            # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ ØµÙÙ‚Ø© Ù…Ù† Ù†ÙØ³ Ø§Ù„Ù†ÙˆØ¹ØŒ Ù„Ø§ Ù†ÙØ¹Ù„ Ø´ÙŠØ¡
            if self.current_position and self.current_position['type'] == signal_type:
                return False
            
            # Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ
            volume = self.calculate_position_size()
            
            # ÙØªØ­ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
            self.current_position = {
                'type': signal_type,
                'volume': volume,
                'open_price': current_price,
                'open_time': datetime.now()
            }
            
            logger.info(f"{'='*60}")
            logger.info(f"ğŸŸ¢ ØªÙ… ÙØªØ­ ØµÙÙ‚Ø© {signal_type.upper()}")
            logger.info(f"   Ø§Ù„Ø­Ø¬Ù…: {volume:.2f} Ù„ÙˆØª")
            logger.info(f"   Ø§Ù„Ø³Ø¹Ø±: {current_price:.5f}")
            logger.info(f"   Ø§Ù„Ø±ØµÙŠØ¯: ${self.current_balance:.2f}")
            logger.info(f"{'='*60}")
            
            return True
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ø§Ù„ØµÙÙ‚Ø©: {e}")
            return False
    
    def close_position(self, current_price: float) -> bool:
        """Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©"""
        if not self.current_position:
            return False
        
        try:
            open_price = self.current_position['open_price']
            volume = self.current_position['volume']
            position_type = self.current_position['type']
            
            # Ø­Ø³Ø§Ø¨ ÙØ±Ù‚ Ø§Ù„Ø³Ø¹Ø±
            if position_type == 'buy':
                price_diff = current_price - open_price
            else:  # sell
                price_diff = open_price - current_price
            
            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©
            # Ø§Ù„Ø±Ø¨Ø­ = ÙØ±Ù‚ Ø§Ù„Ø³Ø¹Ø± Ã— Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ã— 100,000 (Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØª Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ)
            profit = price_diff * volume * 100000
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯
            old_balance = self.current_balance
            self.current_balance += profit
            
            # Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
            trade_record = {
                'type': position_type,
                'open_price': open_price,
                'close_price': current_price,
                'volume': volume,
                'profit': profit,
                'open_time': self.current_position['open_time'],
                'close_time': datetime.now(),
                'balance_before': old_balance,
                'balance_after': self.current_balance
            }
            self.trades_history.append(trade_record)
            
            logger.info(f"{'='*60}")
            logger.info(f"ğŸ”´ ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØµÙÙ‚Ø© {position_type.upper()}")
            logger.info(f"   Ø§Ù„Ø³Ø¹Ø± Ø¹Ù†Ø¯ Ø§Ù„ÙØªØ­: {open_price:.5f}")
            logger.info(f"   Ø§Ù„Ø³Ø¹Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚: {current_price:.5f}")
            logger.info(f"   Ø§Ù„Ø­Ø¬Ù…: {volume:.2f} Ù„ÙˆØª")
            logger.info(f"   Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©: ${profit:+.2f}")
            logger.info(f"   Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚: ${old_balance:.2f}")
            logger.info(f"   Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯: ${self.current_balance:.2f}")
            logger.info(f"   Ø§Ù„ØªØºÙŠØ±: {((self.current_balance/old_balance - 1) * 100):+.2f}%")
            logger.info(f"{'='*60}")
            
            self.current_position = None
            return True
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙÙ‚Ø©: {e}")
            return False
    
    def get_statistics(self) -> Dict:
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„"""
        if not self.trades_history:
            return {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'total_profit': 0,
                'total_loss': 0,
                'net_profit': 0,
                'profit_factor': 0
            }
        
        winning_trades = [t for t in self.trades_history if t['profit'] > 0]
        losing_trades = [t for t in self.trades_history if t['profit'] < 0]
        
        total_profit = sum(t['profit'] for t in winning_trades)
        total_loss = abs(sum(t['profit'] for t in losing_trades))
        
        return {
            'total_trades': len(self.trades_history),
            'winning_trades': len(winning_trades),
            'losing_trades': len(losing_trades),
            'win_rate': len(winning_trades) / len(self.trades_history) * 100 if self.trades_history else 0,
            'total_profit': total_profit,
            'total_loss': total_loss,
            'net_profit': self.current_balance - self.config.INITIAL_BALANCE,
            'profit_factor': total_profit / total_loss if total_loss > 0 else 0
        }


# ============================================================================
# Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
# ============================================================================

class TradingBot:
    """Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ - ÙŠØ¬Ù…Ø¹ ÙƒÙ„ Ø´ÙŠØ¡ Ù…Ø¹Ø§Ù‹"""
    
    def __init__(self):
        self.config = Config()
        self.classifier = LorentzianClassifier()
        self.api = CTraderAPI()
        self.last_signal = 0
        
        logger.info("="*60)
        logger.info("ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­")
        logger.info("="*60)
    
    def print_configuration(self):
        """Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª"""
        logger.info("\n" + "="*60)
        logger.info("âš™ï¸  Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª:")
        logger.info("="*60)
        logger.info(f"Ø§Ù„Ø±Ù…Ø²: {self.config.SYMBOL}")
        logger.info(f"Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø²Ù…Ù†ÙŠ: {self.config.TIMEFRAME}")
        logger.info(f"Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©: 1:{self.config.LEVERAGE}")
        logger.info(f"Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ: ${self.config.INITIAL_BALANCE:.2f}")
        logger.info(f"Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ: {'Ù†Ø¹Ù…' if self.config.USE_CUMULATIVE_BALANCE else 'Ù„Ø§'}")
        logger.info(f"Ø¹Ø¯Ø¯ Ø§Ù„Ø¬ÙŠØ±Ø§Ù†: {self.config.NEIGHBORS_COUNT}")
        logger.info(f"Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©: {self.config.MAX_BARS_BACK}")
        logger.info(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Øª: {self.config.FEATURE_COUNT}")
        logger.info(f"ÙÙ„ØªØ± Ø§Ù„ØªÙ‚Ù„Ø¨: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_VOLATILITY_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info(f"ÙÙ„ØªØ± Ø§Ù„Ù†Ø¸Ø§Ù…: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_REGIME_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info(f"ÙÙ„ØªØ± ADX: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_ADX_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info(f"ÙÙ„ØªØ± EMA: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_EMA_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info(f"ÙÙ„ØªØ± SMA: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_SMA_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info(f"ÙÙ„ØªØ± Kernel: {'Ù…ÙØ¹Ù‘Ù„' if self.config.USE_KERNEL_FILTER else 'Ù…Ø¹Ø·Ù‘Ù„'}")
        logger.info("="*60 + "\n")
    
    def run(self):
        """Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        self.print_configuration()
        
        logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„...")
        logger.info(f"Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙƒÙ„ {self.config.UPDATE_INTERVAL_SECONDS} Ø«Ø§Ù†ÙŠØ©\n")
        
        iteration = 0
        
        try:
            while True:
                iteration += 1
                
                logger.info("\n" + "="*60)
                logger.info(f"ğŸ“Š Ø§Ù„ØªÙƒØ±Ø§Ø± #{iteration} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                logger.info("="*60)
                
                # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
                df = self.api.get_historical_data(bars=self.config.MAX_BARS_BACK)
                
                if df is None or len(df) < 100:
                    logger.warning("âš ï¸ Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©")
                    time.sleep(self.config.UPDATE_INTERVAL_SECONDS)
                    continue
                
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± Ø´Ù…Ø¹Ø©
                current_idx = len(df) - 1
                current_price = df['close'].iloc[current_idx]
                
                # Ø§Ù„ØªÙ†Ø¨Ø¤
                signal, kernel_info = self.classifier.predict(df, current_idx)
                
                # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨
                current_balance = self.api.get_current_balance()
                
                logger.info(f"ğŸ’° Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${current_balance:.2f}")
                logger.info(f"ğŸ’± Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_price:.5f}")
                
                signal_text = "Ø´Ø±Ø§Ø¡ ğŸŸ¢" if signal == 1 else "Ø¨ÙŠØ¹ ğŸ”´" if signal == -1 else "Ù…Ø­Ø§ÙŠØ¯ âšª"
                logger.info(f"ğŸ¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©: {signal} ({signal_text})")
                
                # Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ¯Ø§ÙˆÙ„
                is_new_buy_signal = signal == 1 and self.last_signal != 1
                is_new_sell_signal = signal == -1 and self.last_signal != -1
                
                # ÙÙ„Ø§ØªØ± Kernel
                is_bullish = kernel_info.get('is_bullish', True)
                is_bearish = kernel_info.get('is_bearish', True)
                
                # ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø§Øª
                if is_new_buy_signal and is_bullish:
                    logger.info("âœ… Ø¥Ø´Ø§Ø±Ø© Ø´Ø±Ø§Ø¡ Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¤ÙƒØ¯Ø©!")
                    self.api.open_position('buy', current_price)
                    self.last_signal = 1
                    
                elif is_new_sell_signal and is_bearish:
                    logger.info("âœ… Ø¥Ø´Ø§Ø±Ø© Ø¨ÙŠØ¹ Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¤ÙƒØ¯Ø©!")
                    self.api.open_position('sell', current_price)
                    self.last_signal = -1
                
                else:
                    if signal == 0:
                        logger.info("â¸ï¸  Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø§Ø±Ø© ÙˆØ§Ø¶Ø­Ø© - Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...")
                    else:
                        logger.info(f"â¸ï¸  Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„ÙƒÙ† Ù„Ù… ØªØªØºÙŠØ± - Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ")
                
                # Ø¹Ø±Ø¶ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                if self.api.current_position:
                    pos = self.api.current_position
                    unrealized_pnl = 0
                    if pos['type'] == 'buy':
                        unrealized_pnl = (current_price - pos['open_price']) * pos['volume'] * 100000
                    else:
                        unrealized_pnl = (pos['open_price'] - current_price) * pos['volume'] * 100000
                    
                    logger.info(f"\nğŸ“Œ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…ÙØªÙˆØ­Ø©:")
                    logger.info(f"   Ø§Ù„Ù†ÙˆØ¹: {pos['type'].upper()}")
                    logger.info(f"   Ø§Ù„Ø­Ø¬Ù…: {pos['volume']:.2f} Ù„ÙˆØª")
                    logger.info(f"   Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„: {pos['open_price']:.5f}")
                    logger.info(f"   Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_price:.5f}")
                    logger.info(f"   Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø© ØºÙŠØ± Ø§Ù„Ù…Ø­Ù‚Ù‚: ${unrealized_pnl:+.2f}")
                
                # Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                if iteration % 10 == 0:  # ÙƒÙ„ 10 ØªÙƒØ±Ø§Ø±Ø§Øª
                    stats = self.api.get_statistics()
                    if stats['total_trades'] > 0:
                        logger.info(f"\nğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„:")
                        logger.info(f"   Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙÙ‚Ø§Øª: {stats['total_trades']}")
                        logger.info(f"   ØµÙÙ‚Ø§Øª Ø±Ø§Ø¨Ø­Ø©: {stats['winning_trades']}")
                        logger.info(f"   ØµÙÙ‚Ø§Øª Ø®Ø§Ø³Ø±Ø©: {stats['losing_trades']}")
                        logger.info(f"   Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­: {stats['win_rate']:.1f}%")
                        logger.info(f"   ØµØ§ÙÙŠ Ø§Ù„Ø±Ø¨Ø­: ${stats['net_profit']:+.2f}")
                        logger.info(f"   Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø±Ø¨Ø­: {stats['profit_factor']:.2f}")
                
                logger.info(f"\nâ³ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {self.config.UPDATE_INTERVAL_SECONDS} Ø«Ø§Ù†ÙŠØ© Ø­ØªÙ‰ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ§Ù„ÙŠ...")
                time.sleep(self.config.UPDATE_INTERVAL_SECONDS)
                
        except KeyboardInterrupt:
            logger.info("\n\nâš ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
            self.shutdown()
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ¯Ø§ÙˆÙ„: {e}", exc_info=True)
            self.shutdown()
    
    def shutdown(self):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
        logger.info("\n" + "="*60)
        logger.info("ğŸ›‘ Ø¬Ø§Ø±ÙŠ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª...")
        logger.info("="*60)
        
        # Ø¥ØºÙ„Ø§Ù‚ Ø£ÙŠ ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø©
        if self.api.current_position:
            df = self.api.get_historical_data(bars=10)
            if df is not None:
                current_price = df['close'].iloc[-1]
                self.api.close_position(current_price)
        
        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        stats = self.api.get_statistics()
        current_balance = self.api.get_current_balance()
        initial_balance = self.config.INITIAL_BALANCE
        
        logger.info("\n" + "="*60)
        logger.info("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:")
        logger.info("="*60)
        logger.info(f"Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ: ${initial_balance:.2f}")
        logger.info(f"Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ: ${current_balance:.2f}")
        logger.info(f"ØµØ§ÙÙŠ Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø©: ${current_balance - initial_balance:+.2f}")
        logger.info(f"Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ©: {((current_balance/initial_balance - 1) * 100):+.2f}%")
        logger.info(f"\nØ¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙÙ‚Ø§Øª: {stats['total_trades']}")
        logger.info(f"ØµÙÙ‚Ø§Øª Ø±Ø§Ø¨Ø­Ø©: {stats['winning_trades']}")
        logger.info(f"ØµÙÙ‚Ø§Øª Ø®Ø§Ø³Ø±Ø©: {stats['losing_trades']}")
        logger.info(f"Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­: {stats['win_rate']:.1f}%")
        
        if stats['total_trades'] > 0:
            logger.info(f"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${stats['total_profit']:.2f}")
            logger.info(f"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±: ${stats['total_loss']:.2f}")
            logger.info(f"Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø±Ø¨Ø­: {stats['profit_factor']:.2f}")
        
        logger.info("="*60)
        logger.info("âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­")
        logger.info("="*60 + "\n")


# ============================================================================
# Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
# ============================================================================

def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    
    print("\n" + "="*60)
    print("ğŸ¤– Lorentzian Classification Trading Bot")
    print("="*60)
    print("ØªØ­ÙˆÙŠÙ„ Ù…Ù† Pine Script Ø¥Ù„Ù‰ Python")
    print("Ù„Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø¢Ù„ÙŠ Ø¹Ù„Ù‰ cTrader")
    print("="*60 + "\n")
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    config = Config()
    
    if config.CTRADER_CLIENT_ID == "your_client_id_here":
        logger.warning("âš ï¸ ØªØ­Ø°ÙŠØ±: Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª API!")
        logger.warning("âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Config.CTRADER_CLIENT_ID Ùˆ Config.CTRADER_CLIENT_SECRET")
        logger.info("â„¹ï¸ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ (Ù…Ø­Ø§ÙƒØ§Ø©)...")
        config.USE_DEMO_MODE = True
    
    # Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    bot = TradingBot()
    
    try:
        bot.run()
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙØ§Ø¯Ø­: {e}", exc_info=True)


if __name__ == "__main__":
    main()

# ============================================================================
# Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙƒÙˆØ¯
# ============================================================================
